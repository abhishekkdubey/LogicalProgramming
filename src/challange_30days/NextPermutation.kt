package challange_30days

/**
 * 31. Next Permutation

 * A permutation of an array of integers is an arrangement of its members into a sequence or linear order.
 *
 * For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1].
 * The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).
 *
 * For example, the next permutation of arr = [1,2,3] is [1,3,2].
 * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
 * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.
 * Given an array of integers nums, find the next permutation of nums.
 *
 * The replacement must be in place and use only constant extra memory.
 *
 *
 * Example 1:
 *
 * Input: nums = [1,2,3]
 * Output: [1,3,2]
 * Example 2:
 *
 * Input: nums = [3,2,1]
 * Output: [1,2,3]
 * Example 3:
 *
 * Input: nums = [1,1,5]
 * Output: [1,5,1]
 *
 *
 * Constraints:
 *
 * 1 <= nums.length <= 100
 * 0 <= nums[i] <= 100
 */
class NextPermutation {

    companion object{
        @JvmStatic
        fun main(args: Array<String>) {

            val arr = intArrayOf(1 , 2, 3, 4)
            NextPermutation().nextPermutation(arr)
            println(arr.toList())
        }
    }

    /**
     * TO Generate next permutation with the Given condition, We need to understand the term lexicographically greater permutation.
     * Lexicographically Greater Permutation means if a value is 12345 in an array like {1, 2, 3, 4, 5} and looking for next permutation
     * In that next permutation will the next greater value can be form generated using those numbers which will be 12354 then next permutation will be {1, 2, 3, 5, 4}
     *
     * Will take another sort example if 123 as {1, 2, 3}. The next greater value will be 132 as {1, 3, 2} and next value will be 213 as {2, 1, 3}
     *
     * And in case we reached to the max value can produce by given number. in that case return the smallest value generated by given input. E.g: 321 will always return 123
     *
     * While doing this thing we understand that we need to find the next largest value for given input.
     *
     * For that the brute force approach says like, we need to figure out the all possible permutation and store based on increasing order value then we can easily figure out the next permutation.
     *
     * But, that will take extra memory as size of array to store the sorted value.
     *
     * To achieve this in an optimal way, we can use an Algorithm given in 14th Century by Narayan Pandita according to Wikipedia
     *
     * Algorithm says:
     *  Step 1: Find the largest index `k` such that `nums[k] < nums[k+1]`. If no such exist, Just reverse the number
     *
     *  Step 2: Find the largest index `l > k` where `nums[l]> nums[k]`
     *
     *  Step 3: Swap `nums[k]` and `nums[l]`
     *
     *  Step 4: Revers the sub-array from starting index `nums[k+1]`
     *
     *  Then we'll arrive at the solution, Which can be managed using no extra n space.
     *
     *  Let's hop on the coding part
     */
    fun nextPermutation(nums: IntArray): Unit {

        var k =-1
        var l = 0

        for (i in nums.lastIndex-1 downTo 0){
            if (nums[i+1]>nums[i]){
                k = i
                break
            }
        }

        if (k==-1){
            return nums.reverse()
        }else{
            //Find the index l where nums[l]>nums[k]
            for (j in nums.lastIndex downTo k){
                if (nums[j]>nums[k]){
                    l = j
                    break
                }
            }

            //Swap with nums[l] and nums[k]
            val temp = nums[l]
            nums[l] = nums[k]
            nums[k]=  temp

            nums.reverse(k+1, nums.size)


        }


    }


}